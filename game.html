<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Neo4j Eval Center</title>
    <link rel="stylesheet" type="text/css" href="bootstrap/css/bootstrap.css"/>
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
    <script type="text/javascript" src="js/jquery/jquery-2.0.3.js"></script>
    <script type="text/javascript" src="bootstrap/js/bootstrap.js"></script>

    <script src="js/d3.v3.min.js" charset="utf-8"></script>
    <script src="js/models.js" charset="utf-8"></script>

<style>

.node {
    stroke: #444;
    stroke-width: 2px;
}

.link {
    stroke: #999;
    stroke-opacity: .8;
}

.legend {
    opacity: 0.5;
}

</style>

<script type="text/javascript">

$(document).ready(function() {

var settings = {
    width: 600,
    height: 600,

    forceCharge: -500,
    forceDistance: 50,

    nodeRadius: 10,
    textOffsetX: 10,
    textOffsetY: -5
};

var scale = d3.scale.category10();

var force = d3.layout.force()
    .charge(settings.forceCharge)
    .linkDistance(settings.forceDistance)
    .on("tick", tick)
    .size([settings.width, settings.height]);

var svg = d3.select("body").append("svg")
    .attr("width", settings.width)
    .attr("height", settings.height);
var linkGroup = svg.append("g").attr("class", "links");
var nodeGroup = svg.append("g").attr("class", "nodes");
var legendGroup = svg.append("g").attr("class", "legend");

var link, node, text, legend;


var model = 
    // socialModel;
    // productCatalogModel;
    networkManagementModel;
prepareModel(model);

function prepareModel(m) {
    m.links.forEach(function(l) {
        l.source = m.nodes[l.source];
        l.target = m.nodes[l.target];
    });
}

function update() {

    var nodes = model.nodes.filter(function(n) {return n._visible;});
    var links = model.links.filter(function(l) {
        return l.source._expanded || l.target._expanded;
    });

    force
        .nodes(nodes)
        .links(links)
        .start();

    link = linkGroup.selectAll(".link")
        .data(links);
    link.enter().append("line")
        .attr("class", "link");
    link.exit().remove();

    node = nodeGroup.selectAll(".node")
        .data(nodes)
        .style("fill", nodeColor)
        .style("stroke-dasharray", strokeDasharray);
    node.enter()
        .append("circle")
            .attr("class", "node")
            .attr("r", settings.nodeRadius)
            .style("fill", nodeColor)
            .style("stroke-dasharray", strokeDasharray)
            .on("click", expand)
            .call(force.drag);
    node.exit().remove();

    text = nodeGroup.selectAll(".text")
        .data(nodes)
        .text(function (d) { return d.name; });
    text.enter()
        .append("text")
            .attr("class", "text")
            .text(function (d) { return d.name; });
    text.exit().remove();

    legend = legendGroup.selectAll(".legend")
        .data(model.labels);
    legend.enter().append("circle")
            .attr("class", "node")
            .attr("r", settings.nodeRadius)
            .attr("cx", settings.nodeRadius*2)
            .attr("cy", function(d, i) { return settings.nodeRadius*2 + (i) * settings.nodeRadius*3; })
            .style("fill", legendColor);
    legend.enter()
            .append("text")
            .attr("x", settings.nodeRadius*4)
            .attr("y", function(d, i) { return settings.nodeRadius*2.5 + (i) * settings.nodeRadius*3; })
            .text(function(d) { return d; });

}

function expand(node) {
    if (node._expanded === true) return;
    node._expanded = true;
    getNeighborLinks(node).forEach(function(link) {
        show(getOtherNode(node, link));
    });
    update();
}

function show(node) {
    node._visible = true;
    var neighbors = getNeighborNodes(node);
    var numExpandedNeighbors = neighbors.filter(function(node) { return node._expanded; }).length;
    if (neighbors.length == numExpandedNeighbors) {
        node._expanded = true;
    }
}

function getNeighborLinks(node) {
    return model.links.filter(function(link) {
        return nodeHasLink(node, link);
    });
}

function getNeighborNodes(node) {
    return getNeighborLinks(node).map(function (link) {
        return getOtherNode(node, link);
    });
}

function nodeHasLink(node, link) {
    return getOtherNode(node, link) !== null;
}

function getOtherNode(node, link) {
    if (link.source === node) return link.target;
    if (link.target === node) return link.source;
    return null;
}

function nodeColor(d) {
    return scale(d.label)
}

function legendColor(d) {
    return scale(d)
}

function strokeDasharray(d) {
    return d._expanded ? "0" : "2.5";
}

function tick(e) {
    if (model.style == "tree") {
        var k = 20 * e.alpha;
        model.links.forEach(function (d, i) {
            d.source.y -= k;
            d.target.y += k;
        });
    }

    link.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });

    text.attr("x", function(d) { return d.x + settings.textOffsetX; })
        .attr("y", function(d) { return d.y + settings.textOffsetY; });
}

update();

});
    </script>
</head>
<body>

</body>
</html>
